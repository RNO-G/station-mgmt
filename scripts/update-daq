#! /usr/bin/env python3

import sys
import tempfile
import os

#usage
#  update-daq [-ys] host  repo0[[[:branch=default]/target=default]/target2=default2]

# example:   update-daq -y amaroq librno-g:feature/install-daq  stationrc



confirm = True  # require confirmation
sudo = False    # ask for sudo at beginning
host = None
just_print_defaults = False
repos = []


def usage():
    print("update-daq [-Dyhs] host repo[[[:branch]/make-target0]/make-target1...]  [additional repos] ")
    print("  -y  yolo mode (no confirmation)")
    print("  -s  ask for sudo")
    print("  -h  useless help prompt")
    print("  -D  just list defaults for the repos rather than doing anything else. (host not taken in this case)\n")
    print("    host something known to ssh\n")
    print("    can list as many repos as you want, first repo name, then optionally a branch if not using the default branch after a colon, then optionally a slash separated list of make targets")
    print("    None is a special make target that doesn't run make (e.g. if there is no Makefile...)")
    print()
    print("    Examples: ")
    print("    update-daq nanoq librno-g rno-g-ice-software  # update librno-g, rno-g-ice-software on nanoq with default branches, default install targets")
    print("    update-daq -y amaroq librno-g rno-g-ice-software:devel/install/cfg-install  # devel branch of rno-g-ice-sotware, run both install and cfg-install targets for rno-g-ice-sftware, no confirmation")


#git recipes
def get_default_branch(repo : str):
    if repo == "radiant-python":
        return "summit-branch"

    if repo in ("stationrc","micromini-firmware"):
        return "main"

    return "master"

#targets

def get_default_targets(repo : str):

    if repo == "librno-g":
        return ["install-daq"]

    if repo in ("stationrc","radiant-python","rnog_gps"):
        return []

    if repo in ("micromini-firmware","control-uC"):
        return ["client"]

    return ["install"]


for arg in sys.argv[1:]:
    if arg=="-y":
        confirm = False
    elif arg=="-s":
        sudo = True
    elif arg=="-h":
        usage()
        sys.exit(0)
    elif arg == '-D':
        just_print_defaults = True
    elif host==None and not just_print_defaults:
        host = arg
    else:
        split_slashes = arg.split("/")
        if (split_slashes[0] == ''):
            print("Empty repo")
            sys.exit(1)
        split_colons = split_slashes[0].split(":")
        if len(split_colons) > 2 or split_colons[0] == '':
            print("Bad repo:branch specification")
            sys.exit(1)
        name = split_colons[0]
        if just_print_defaults:
            print("[%s]\n  default-branch: %s\n  default-targets: %s\n\n" % (name, get_default_branch(name), get_default_targets(name)))
        else:
            branch = get_default_branch(name) if len(split_colons) == 1 else split_colons[1]
            targets = get_default_targets(name) if len(split_slashes) == 1 else split_slashes[1:]
            if len(targets) > 0 and targets[0] == 'None':
                targets = []

            repos.append({"name": name, "branch": branch, "targets": targets})


if just_print_defaults:
    sys.exit(0)

if host == None or len(repos) == 0:
    usage()
    sys.exit(1)

script = (R"""#! /bin/sh
cat /STATION_ID
""")

if sudo:
    script+="#get sudo privileges at beginning\nsudo hostname\n"
else:
    script+=("hostname\n")

for repo in repos:

    script+=("\n#---\n#%s\n#---\n"%(repo['name']))
    script+=("cd /home/rno-g/%s\n" % (repo['name']))
    script+=("echo Handling %s\n" % (repo['name']))
    script+=("git checkout %s\ngit pull origin %s\n"% (repo['branch'], repo['branch']))
    for target in repo['targets']:
        script+=("make %s\n" %(target))

script += "\n\necho 'Done!'\n\n"
if confirm:
    print("We will send the following script to '%s': " % (host))
    print(script)
    answer = input("Ok? [y/N]").lower()

    if answer != "y":
        sys.exit(1)


with tempfile.NamedTemporaryFile(delete_on_close=False) as tmp:
    tmp.write(script.encode())
    tmp.close()
    os.system("ssh -T %s < %s" % (host, tmp.name))


